# 🚀 Fast Pass 프로젝트 회고 (Retrospective)

## 1. 프로젝트 개요

**Fast Pass**는 대규모 트래픽이 몰리는 상황에서도 안정적인 좌석 예약 시스템을 구축하기 위한 프로젝트입니다. 콘서트 티켓팅과 같은 **선착순 예약 시나리오**를 처리하기 위해 동시성 제어와 시스템 성능 최적화에 중점을 두었습니다.

## 2. 주요 구현 기능

- **인증 및 인가 (Auth)**: JWT 기반의 회원가입, 로그인, 로그아웃 시스템.
- **공연 및 좌석 관리 (Event/Performance/Seat)**:
  - 공연 생성 및 100~수천 개의 좌석 배치 자동 생성.
  - 좌석 상태 관리 (AVAILABLE -> HELD -> OCCUPIED).
- **예약 시스템 (Reservation)**:
  - **Redis 분산 락**을 이용한 1차 동시성 제어.
  - **DB 낙관적 락(Optimistic Lock)**을 이용한 2차 데이터 무결성 보장.
  - 예약 만료 정책 (Scheduler) 도입: 미결제 좌석 자동 반환.
- **모니터링 및 로깅**: Winston Logger 및 Prometheus/Grafana(K6 Dashboard) 활용.

## 3. 기술적 도전 및 해결 과정

### 🛠 동시성 제어 (Concurrency Control)

가장 큰 과제는 **"동일한 좌석에 대한 중복 예약 방지"**였습니다.

1.  **1차 시도 (Redis Distributed Lock)**:
    - `Redlock` 알고리즘을 사용하여 좌석 예약을 시도하기 전 분산 락을 획득하도록 구현했습니다.
    - **효과**: 대부분의 레이스 컨디션을 방어하고 DB 부하를 줄임.
    - **한계**: 락 획득 실패 시 유저 경험 처리, 락 만료 시간(TTL) 설정의 정교함 필요.

2.  **2차 시도 (Database Optimistic Lock)**:
    - Redis 락이 만료되거나 실패하는 엣지 케이스를 대비하여 DB 레벨의 안전장치를 추가했습니다.
    - `version` 필드를 활용한 Raw Query(`UPDATE ... WHERE version = current_version`) 도입.
    - **성과**: **데이터 정합성 100% 보장**. 부하 테스트 시 단 한 건의 중복 예약도 발생하지 않음.

### ⚡️ 대용량 부하 테스트 (Load Testing)

`K6`를 사용하여 실제 트래픽과 유사한 환경을 시뮬레이션했습니다.

- **시나리오**: 50~500명의 가상 유저(VU)가 동시에 예약 `POST` 요청.
- **결과**:
  - **50 VUs**: 평균 응답 시간 10ms 내외, p(95) **21ms**. 매우 쾌적함.
  - **500 VUs**: p(95) **464ms**. 로컬 환경의 자원 한계로 인한 지연 발생.
- **인사이트**: 애플리케이션 로직(락 획득 대기 등)보다 DB Connection 및 I/O 병목이 먼저 옴을 확인.

## 4. 잘한 점 (Keep)

- **이중 잠금 장치**: Redis와 DB Lock을 모두 사용하여 성능과 안정성 두 마리 토끼를 잡은 아키텍처.
- **자동화된 테스트**: K6 스크립트를 통해 CI/CD 파이프라인에서 성능을 검증할 수 있는 기반 마련.
- **코드 품질**: NestJS의 모듈 패턴을 준수하고, DTO 유효성 검사 및 예외 처리를 꼼꼼히 하여 409 Conflict 등의 상태 코드를 명확히 반환함.

## 5. 아쉬운 점 및 향후 개선 과제 (Improvement)

- **로컬 테스트의 한계**: 로컬 Docker 환경에서 모든 서비스를 띄우다 보니 부하 테스트 시 정확한 병목 구간(CPU vs Network)을 격리하여 분석하기 어려웠음.
- **대기열 시스템 부재**: 500명 이상의 유저가 몰릴 경우 바로 409 에러를 뱉는 대신, **Kafka**나 **Redis**를 활용한 대기열(Waiting Queue) 시스템을 도입하여 유저 경험을 개선할 필요가 있음.
- **데이터베이스 쓰기 부하**: 예약 확정 시 `Transaction`이 길어질 수 있음. CQRS 패턴을 고려하여 읽기/쓰기 모델을 분리하면 조회가 잦은 좌석 확인 성능을 더 높일 수 있음.

---

**총평**: 이번 프로젝트를 통해 동시성 문제가 발생하는 실제 메커니즘을 깊이 이해하고, 이를 해결하기 위한 다양한 계층(Application/Cache/DB)의 전략을 성공적으로 적용해볼 수 있었습니다.
